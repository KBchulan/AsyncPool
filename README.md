# AsyncPool
​	首先应该明白的是线程池的应用场景：如果我们的项目中存在大量短生命周期线程（并发任务处理，网络服务如asio ，以及对性能有要求的场景），那么便可以通过使用线程池来减少线程的创建和销毁。此外，这实在只能算的上一个小知识点，作者单独开一个仓库是方便以后直接使用，就跟算法的板子一样，因此写的尽可能省略，如果想知晓具体应用，可查看作者其他仓库或者自行上网学习。

## 设计思路：

​	总述：线程池的整体思想是预先创建一定数量的线程，由池进行统一管理，将任务分配给空闲线程进行执行，而不是针对某一个任务创建和销毁线程（这样实在不是一个好的思路）。

#### 组成：

1. 线程池管理器：负责线程的统一创建和销毁，并维护线程的状态切换。
2. 任务队列：存储需要执行的任务对象，经常会以函数封装器（基本是lambda和bind，或者回调嵌套封装）的形式存入队列。
3. 工作线程：管理器中取出任务的线程们。
4. 同步和异步机制：同步是为了保护我们的线程安全（如通过互斥锁、读写锁、条件变量或者信号量），确保memory和CPU寄存器的稳定切换；异步则是为了保证我们能够更加灵活的操作多线程的数据。

## 随笔：

​	记录一下作者在写这个文档时的随心所想，并不与此知识点直接相关

一.游戏界面设计：

1. 以往经常是枚举（默认全局可见）和静态哈希表维护一个所有场景的表，但是弊端也很明显，过多的场景必然会造成资源的拥堵和内存的高开销，现在想来是十分不好的；
2. 还采取过通过一个栈的方式封装一个类，储存场景的公有方法，这个方案确实不错，但是在引入一些计时器还有动画类型时其实是有一些问题的，所有的负担都堆到了进程退化的线程上，感觉多了就不是很好；
3. 感觉现在就可以通过线程池来实现这个功能，下一次写游戏会尝试增加上去。

二.实现思路：

​	其实能看出来，这个设计思路和我们的游戏开发基本一致，Manager----CRTP---->特化管理器，类型管理器储存同类静态对象、当前对象和一些方法以满足需求，不知该说是思维固化还是万物皈依。
